import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  add_location,
  append_dev,
  append_styles,
  attr_dev,
  binding_callbacks,
  check_outros,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  get_all_dirty_from_scope,
  get_slot_changes,
  globals,
  group_outros,
  init,
  insert_dev,
  listen_dev,
  mount_component,
  noop,
  onMount,
  run_all,
  safe_not_equal,
  set_style,
  space,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-TVA3GBF4.js";
import "./chunk-IVLCYF2H.js";

// node_modules/svelte-slider/src/Rail.svelte
var file = "node_modules/svelte-slider/src/Rail.svelte";
function add_css(target) {
  append_styles(target, "svelte-1u5xdj2", ".rail.svelte-1u5xdj2{position:relative;height:2px;background:var(--sliderSecondary)}.selected.svelte-1u5xdj2{position:absolute;left:0;right:0;top:0;bottom:0;background:var(--sliderPrimary)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmFpbC5zdmVsdGUiLCJzb3VyY2VzIjpbIlJhaWwuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG4gIGV4cG9ydCBsZXQgdmFsdWU7XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cInJhaWxcIj5cbiAgPGRpdiBjbGFzcz1cInNlbGVjdGVkXCIgc3R5bGU9XCJsZWZ0OiB7dmFsdWVbMF0gKiAxMDB9JTsgcmlnaHQ6IHsoMSAtIHZhbHVlWzFdKSAqIDEwMH0lO1wiPjwvZGl2PlxuICA8c2xvdD48L3Nsb3Q+XG48L2Rpdj5cblxuPHN0eWxlPlxuICAucmFpbCB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGhlaWdodDogMnB4O1xuICAgIGJhY2tncm91bmQ6IHZhcigtLXNsaWRlclNlY29uZGFyeSk7XG4gIH1cblxuICAuc2VsZWN0ZWQge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBsZWZ0OiAwO1xuICAgIHJpZ2h0OiAwO1xuICAgIHRvcDogMDtcbiAgICBib3R0b206IDA7XG4gICAgYmFja2dyb3VuZDogdmFyKC0tc2xpZGVyUHJpbWFyeSk7XG4gIH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBVUUsS0FBSyxlQUFDLENBQUMsQUFDTCxRQUFRLENBQUUsUUFBUSxDQUNsQixNQUFNLENBQUUsR0FBRyxDQUNYLFVBQVUsQ0FBRSxJQUFJLGlCQUFpQixDQUFDLEFBQ3BDLENBQUMsQUFFRCxTQUFTLGVBQUMsQ0FBQyxBQUNULFFBQVEsQ0FBRSxRQUFRLENBQ2xCLElBQUksQ0FBRSxDQUFDLENBQ1AsS0FBSyxDQUFFLENBQUMsQ0FDUixHQUFHLENBQUUsQ0FBQyxDQUNOLE1BQU0sQ0FBRSxDQUFDLENBQ1QsVUFBVSxDQUFFLElBQUksZUFBZSxDQUFDLEFBQ2xDLENBQUMifQ== */");
}
function create_fragment(ctx) {
  let div1;
  let div0;
  let t;
  let current;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      t = space();
      if (default_slot)
        default_slot.c();
      attr_dev(div0, "class", "selected svelte-1u5xdj2");
      set_style(div0, "left", ctx[0][0] * 100 + "%");
      set_style(div0, "right", (1 - ctx[0][1]) * 100 + "%");
      add_location(div0, file, 5, 2, 61);
      attr_dev(div1, "class", "rail svelte-1u5xdj2");
      add_location(div1, file, 4, 0, 40);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      append_dev(div1, t);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & 1) {
        set_style(div0, "left", ctx2[0][0] * 100 + "%");
      }
      if (!current || dirty & 1) {
        set_style(div0, "right", (1 - ctx2[0][1]) * 100 + "%");
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[1],
            !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Rail", slots, ["default"]);
  let { value } = $$props;
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<Rail> was created without expected prop 'value'");
    }
  });
  const writable_props = ["value"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Rail> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ value });
  $$self.$inject_state = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [value, $$scope, slots];
}
var Rail = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { value: 0 }, add_css);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Rail",
      options,
      id: create_fragment.name
    });
  }
  get value() {
    throw new Error("<Rail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Rail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Rail_default = Rail;

// node_modules/svelte-slider/src/Thumb.svelte
var file2 = "node_modules/svelte-slider/src/Thumb.svelte";
function add_css2(target) {
  append_styles(target, "svelte-1p2qw86", ".thumb.svelte-1p2qw86{width:16px;height:16px;position:absolute;left:0;top:50%;border-radius:50%;background:var(--sliderPrimary);touch-action:none;transform:translate(-50%, -50%);transition:.2s height, .2s width}.thumb.svelte-1p2qw86:after{content:'';position:absolute;left:50%;top:50%;width:32px;height:32px;transform:translate(-50%, -50%);cursor:pointer}.thumb.svelte-1p2qw86:before{content:'';position:absolute;left:50%;top:50%;width:32px;height:32px;border-radius:50%;opacity:0.3;background:var(--sliderSecondary);transform:translate(-50%, -50%) scale(0);transition:.2s all}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGh1bWIuc3ZlbHRlIiwic291cmNlcyI6WyJUaHVtYi5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgaW1wb3J0IHsgb25Nb3VudCwgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnc3ZlbHRlJztcblxuICBleHBvcnQgbGV0IHBvc2l0aW9uO1xuXG4gIGxldCB0aHVtYjtcbiAgbGV0IGJib3g7XG4gIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cbiAgZnVuY3Rpb24gaGFuZGxlU3RhcnQoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHggPSBldmVudC5jbGllbnRYO1xuICAgIGNvbnN0IGJib3ggPSBldmVudC50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdGh1bWIuc2V0UG9pbnRlckNhcHR1cmUoZXZlbnQucG9pbnRlcklkKTtcbiAgICB0aHVtYi5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIGhhbmRsZU1vdmUpO1xuICAgIHRodW1iLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIGhhbmRsZUVuZCk7XG4gICAgZGlzcGF0Y2goJ2RyYWdzdGFydCcsIHsgeCwgYmJveCB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU1vdmUoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHggPSBldmVudC5jbGllbnRYO1xuICAgIGNvbnN0IGJib3ggPSBldmVudC50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgZGlzcGF0Y2goJ2RyYWdnaW5nJywgeyB4LCBiYm94IH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlRW5kKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aHVtYi5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIGhhbmRsZU1vdmUpO1xuICAgIHRodW1iLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIGhhbmRsZUVuZCk7XG4gICAgZGlzcGF0Y2goJ2RyYWdlbmQnKTtcbiAgfVxuXG4gIG9uTW91bnQoKCkgPT4ge1xuICAgIHRodW1iLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgaGFuZGxlU3RhcnQpO1xuICB9KTtcbjwvc2NyaXB0PlxuXG48ZGl2XG4gIGJpbmQ6dGhpcz17dGh1bWJ9XG4gIGNsYXNzPVwidGh1bWJcIlxuICBzdHlsZT1cImxlZnQ6IHtwb3NpdGlvbiAqIDEwMH0lO1wiXG4gIG9uOnN0YXJ0PXtoYW5kbGVTdGFydH1cbiAgb246bW92ZT17aGFuZGxlTW92ZX1cbiAgb246ZW5kPXtoYW5kbGVFbmR9XG4+XG48L2Rpdj5cblxuPHN0eWxlPlxuICAudGh1bWIge1xuICAgIHdpZHRoOiAxNnB4O1xuICAgIGhlaWdodDogMTZweDtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgbGVmdDogMDtcbiAgICB0b3A6IDUwJTtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgYmFja2dyb3VuZDogdmFyKC0tc2xpZGVyUHJpbWFyeSk7XG4gICAgdG91Y2gtYWN0aW9uOiBub25lO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuICAgIHRyYW5zaXRpb246IC4ycyBoZWlnaHQsIC4ycyB3aWR0aDtcbiAgfVxuXG4gIC50aHVtYjphZnRlciB7XG4gICAgY29udGVudDogJyc7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGxlZnQ6IDUwJTtcbiAgICB0b3A6IDUwJTtcbiAgICB3aWR0aDogMzJweDtcbiAgICBoZWlnaHQ6IDMycHg7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICB9XG5cbiAgLnRodW1iOmJlZm9yZSB7XG4gICAgY29udGVudDogJyc7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGxlZnQ6IDUwJTtcbiAgICB0b3A6IDUwJTtcbiAgICB3aWR0aDogMzJweDtcbiAgICBoZWlnaHQ6IDMycHg7XG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgIG9wYWNpdHk6IDAuMztcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1zbGlkZXJTZWNvbmRhcnkpO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpIHNjYWxlKDApO1xuICAgIHRyYW5zaXRpb246IC4ycyBhbGw7XG4gIH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBaURFLE1BQU0sZUFBQyxDQUFDLEFBQ04sS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxDQUNaLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLElBQUksQ0FBRSxDQUFDLENBQ1AsR0FBRyxDQUFFLEdBQUcsQ0FDUixhQUFhLENBQUUsR0FBRyxDQUNsQixVQUFVLENBQUUsSUFBSSxlQUFlLENBQUMsQ0FDaEMsWUFBWSxDQUFFLElBQUksQ0FDbEIsU0FBUyxDQUFFLFVBQVUsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQ2hDLFVBQVUsQ0FBRSxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQUFDbkMsQ0FBQyxBQUVELHFCQUFNLE1BQU0sQUFBQyxDQUFDLEFBQ1osT0FBTyxDQUFFLEVBQUUsQ0FDWCxRQUFRLENBQUUsUUFBUSxDQUNsQixJQUFJLENBQUUsR0FBRyxDQUNULEdBQUcsQ0FBRSxHQUFHLENBQ1IsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxDQUNaLFNBQVMsQ0FBRSxVQUFVLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUNoQyxNQUFNLENBQUUsT0FBTyxBQUNqQixDQUFDLEFBRUQscUJBQU0sT0FBTyxBQUFDLENBQUMsQUFDYixPQUFPLENBQUUsRUFBRSxDQUNYLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLElBQUksQ0FBRSxHQUFHLENBQ1QsR0FBRyxDQUFFLEdBQUcsQ0FDUixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUFJLENBQ1osYUFBYSxDQUFFLEdBQUcsQ0FDbEIsT0FBTyxDQUFFLEdBQUcsQ0FDWixVQUFVLENBQUUsSUFBSSxpQkFBaUIsQ0FBQyxDQUNsQyxTQUFTLENBQUUsVUFBVSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUN6QyxVQUFVLENBQUUsR0FBRyxDQUFDLEdBQUcsQUFDckIsQ0FBQyJ9 */");
}
function create_fragment2(ctx) {
  let div;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "thumb svelte-1p2qw86");
      set_style(div, "left", ctx[0] * 100 + "%");
      add_location(div, file2, 38, 0, 984);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      ctx[5](div);
      if (!mounted) {
        dispose = [
          listen_dev(div, "start", ctx[2], false, false, false),
          listen_dev(div, "move", ctx[3], false, false, false),
          listen_dev(div, "end", ctx[4], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 1) {
        set_style(div, "left", ctx2[0] * 100 + "%");
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[5](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Thumb", slots, []);
  let { position } = $$props;
  let thumb;
  let bbox;
  const dispatch = createEventDispatcher();
  function handleStart(event) {
    event.preventDefault();
    const x = event.clientX;
    const bbox2 = event.target.getBoundingClientRect();
    thumb.setPointerCapture(event.pointerId);
    thumb.addEventListener("pointermove", handleMove);
    thumb.addEventListener("pointerup", handleEnd);
    dispatch("dragstart", { x, bbox: bbox2 });
  }
  function handleMove(event) {
    event.preventDefault();
    const x = event.clientX;
    const bbox2 = event.target.getBoundingClientRect();
    dispatch("dragging", { x, bbox: bbox2 });
  }
  function handleEnd(event) {
    event.preventDefault();
    thumb.removeEventListener("pointermove", handleMove);
    thumb.removeEventListener("pointerup", handleEnd);
    dispatch("dragend");
  }
  onMount(() => {
    thumb.addEventListener("pointerdown", handleStart);
  });
  $$self.$$.on_mount.push(function() {
    if (position === void 0 && !("position" in $$props || $$self.$$.bound[$$self.$$.props["position"]])) {
      console.warn("<Thumb> was created without expected prop 'position'");
    }
  });
  const writable_props = ["position"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Thumb> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      thumb = $$value;
      $$invalidate(1, thumb);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(0, position = $$props2.position);
  };
  $$self.$capture_state = () => ({
    onMount,
    createEventDispatcher,
    position,
    thumb,
    bbox,
    dispatch,
    handleStart,
    handleMove,
    handleEnd
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(0, position = $$props2.position);
    if ("thumb" in $$props2)
      $$invalidate(1, thumb = $$props2.thumb);
    if ("bbox" in $$props2)
      bbox = $$props2.bbox;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [position, thumb, handleStart, handleMove, handleEnd, div_binding];
}
var Thumb = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { position: 0 }, add_css2);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Thumb",
      options,
      id: create_fragment2.name
    });
  }
  get position() {
    throw new Error("<Thumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Thumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Thumb_default = Thumb;

// node_modules/svelte-slider/src/Slider.svelte
var { console: console_1 } = globals;
var file3 = "node_modules/svelte-slider/src/Slider.svelte";
function add_css3(target) {
  append_styles(target, "svelte-1cw3o64", ".slider.svelte-1cw3o64{padding:8px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2xpZGVyLnN2ZWx0ZSIsInNvdXJjZXMiOlsiU2xpZGVyLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnO1xuICBpbXBvcnQgUmFpbCBmcm9tICcuL1JhaWwuc3ZlbHRlJztcbiAgaW1wb3J0IFRodW1iIGZyb20gJy4vVGh1bWIuc3ZlbHRlJztcblxuICBleHBvcnQgbGV0IHZhbHVlID0gWzAsIDFdO1xuICBleHBvcnQgbGV0IHNpbmdsZSA9IGZhbHNlO1xuXG4gIGxldCBjb250YWluZXI7XG4gIGxldCBhY3RpdmVJbmRleDtcbiAgbGV0IG9mZnNldDtcbiAgbGV0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cbiAgZnVuY3Rpb24gZ2V0U3RhcnRMaXN0ZW5lcihpbmRleCkge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgIGFjdGl2ZUluZGV4ID0gaW5kZXg7XG4gICAgICBjb25zdCB7IGJib3ggfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgIG9mZnNldCA9IGJib3gud2lkdGggLyAyIC0gKGV2ZW50LmRldGFpbC54IC0gYmJveC5sZWZ0KTtcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdmVMaXN0ZW5lcihldmVudCkge1xuICAgIGNvbnN0IGJib3ggPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgeyB4IH0gPSBldmVudC5kZXRhaWw7XG4gICAgbGV0IHBvc2l0aW9uID0gKHggLSBiYm94LmxlZnQgKyBvZmZzZXQpIC8gYmJveC53aWR0aDtcblxuICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgIHBvc2l0aW9uID0gMDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID4gMSkge1xuICAgICAgcG9zaXRpb24gPSAxO1xuICAgIH1cblxuICAgIGlmIChhY3RpdmVJbmRleCA9PT0gMCAmJiB2YWx1ZVswXSA+IHZhbHVlWzFdKSB7XG4gICAgICBhY3RpdmVJbmRleCA9IDE7XG4gICAgICB2YWx1ZVswXSA9IHZhbHVlWzFdO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoYWN0aXZlSW5kZXggPT09IDEgJiYgdmFsdWVbMV0gPCB2YWx1ZVswXSkge1xuICAgICAgYWN0aXZlSW5kZXggPSAwO1xuICAgICAgdmFsdWVbMV0gPSB2YWx1ZVswXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodmFsdWVbYWN0aXZlSW5kZXhdID09PSBwb3NpdGlvbikgcmV0dXJuO1xuICAgIHZhbHVlW2FjdGl2ZUluZGV4XSA9IHBvc2l0aW9uO1xuICAgIGRpc3BhdGNoKCdjaGFuZ2UnLCB2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBlbmRMaXN0ZW5lcigpIHtcbiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLmN1cnNvciA9ICcnO1xuICB9XG5cbiAgZnVuY3Rpb24gb25TZXQoZXZlbnQpIHtcbiAgICBjb25zb2xlLmxvZyhldmVudC5kZXRhaWwpO1xuICB9XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cInNsaWRlclwiPlxuICA8ZGl2IGJpbmQ6dGhpcz17Y29udGFpbmVyfT5cbiAgICA8UmFpbCB7dmFsdWV9IG9uOnNldD17b25TZXR9PlxuICAgICAgeyNpZiAhc2luZ2xlfVxuICAgICAgICA8VGh1bWJcbiAgICAgICAgICBwb3NpdGlvbj17dmFsdWVbMF19XG4gICAgICAgICAgb246ZHJhZ3N0YXJ0PXtnZXRTdGFydExpc3RlbmVyKDApfVxuICAgICAgICAgIG9uOmRyYWdnaW5nPXttb3ZlTGlzdGVuZXJ9XG4gICAgICAgICAgb246ZHJhZ2VuZD17ZW5kTGlzdGVuZXJ9XG4gICAgICAgIC8+XG4gICAgICB7L2lmfVxuICAgICAgPFRodW1iXG4gICAgICAgIHBvc2l0aW9uPXt2YWx1ZVsxXX1cbiAgICAgICAgb246ZHJhZ3N0YXJ0PXtnZXRTdGFydExpc3RlbmVyKDEpfVxuICAgICAgICBvbjpkcmFnZ2luZz17bW92ZUxpc3RlbmVyfVxuICAgICAgICBvbjpkcmFnZW5kPXtlbmRMaXN0ZW5lcn1cbiAgICAgIC8+XG4gICAgPC9SYWlsPlxuICA8L2Rpdj5cbjwvZGl2PlxuXG48c3R5bGU+XG4gIC5zbGlkZXIge1xuICAgIHBhZGRpbmc6IDhweDtcbiAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUErRUUsT0FBTyxlQUFDLENBQUMsQUFDUCxPQUFPLENBQUUsR0FBRyxBQUNkLENBQUMifQ== */");
}
function create_if_block(ctx) {
  let thumb;
  let current;
  thumb = new Thumb_default({
    props: { position: ctx[0][0] },
    $$inline: true
  });
  thumb.$on("dragstart", ctx[3](0));
  thumb.$on("dragging", ctx[4]);
  thumb.$on("dragend", endListener);
  const block = {
    c: function create() {
      create_component(thumb.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(thumb, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const thumb_changes = {};
      if (dirty & 1)
        thumb_changes.position = ctx2[0][0];
      thumb.$set(thumb_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(thumb.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(thumb.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(thumb, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(61:6) {#if !single}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let t;
  let thumb;
  let current;
  let if_block = !ctx[1] && create_if_block(ctx);
  thumb = new Thumb_default({
    props: { position: ctx[0][1] },
    $$inline: true
  });
  thumb.$on("dragstart", ctx[3](1));
  thumb.$on("dragging", ctx[4]);
  thumb.$on("dragend", endListener);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      create_component(thumb.$$.fragment);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, t, anchor);
      mount_component(thumb, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const thumb_changes = {};
      if (dirty & 1)
        thumb_changes.position = ctx2[0][1];
      thumb.$set(thumb_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(thumb.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(thumb.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(thumb, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(60:4) <Rail {value} on:set={onSet}>",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let div1;
  let div0;
  let rail;
  let current;
  rail = new Rail_default({
    props: {
      value: ctx[0],
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  rail.$on("set", onSet);
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      create_component(rail.$$.fragment);
      add_location(div0, file3, 58, 2, 1338);
      attr_dev(div1, "class", "slider svelte-1cw3o64");
      add_location(div1, file3, 57, 0, 1315);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      mount_component(rail, div0, null);
      ctx[5](div0);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const rail_changes = {};
      if (dirty & 1)
        rail_changes.value = ctx2[0];
      if (dirty & 515) {
        rail_changes.$$scope = { dirty, ctx: ctx2 };
      }
      rail.$set(rail_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(rail.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rail.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(rail);
      ctx[5](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function endListener() {
  document.body.style.cursor = "";
}
function onSet(event) {
  console.log(event.detail);
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Slider", slots, []);
  let { value = [0, 1] } = $$props;
  let { single = false } = $$props;
  let container;
  let activeIndex;
  let offset;
  let dispatch = createEventDispatcher();
  function getStartListener(index) {
    return (event) => {
      activeIndex = index;
      const { bbox } = event.detail;
      offset = bbox.width / 2 - (event.detail.x - bbox.left);
      document.body.style.cursor = "pointer";
    };
  }
  function moveListener(event) {
    const bbox = container.getBoundingClientRect();
    const { x } = event.detail;
    let position = (x - bbox.left + offset) / bbox.width;
    if (position < 0) {
      position = 0;
    } else if (position > 1) {
      position = 1;
    }
    if (activeIndex === 0 && value[0] > value[1]) {
      activeIndex = 1;
      $$invalidate(0, value[0] = value[1], value);
      return;
    } else if (activeIndex === 1 && value[1] < value[0]) {
      activeIndex = 0;
      $$invalidate(0, value[1] = value[0], value);
      return;
    }
    if (value[activeIndex] === position)
      return;
    $$invalidate(0, value[activeIndex] = position, value);
    dispatch("change", value);
  }
  const writable_props = ["value", "single"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_1.warn(`<Slider> was created with unknown prop '${key}'`);
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(2, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("single" in $$props2)
      $$invalidate(1, single = $$props2.single);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    Rail: Rail_default,
    Thumb: Thumb_default,
    value,
    single,
    container,
    activeIndex,
    offset,
    dispatch,
    getStartListener,
    moveListener,
    endListener,
    onSet
  });
  $$self.$inject_state = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("single" in $$props2)
      $$invalidate(1, single = $$props2.single);
    if ("container" in $$props2)
      $$invalidate(2, container = $$props2.container);
    if ("activeIndex" in $$props2)
      activeIndex = $$props2.activeIndex;
    if ("offset" in $$props2)
      offset = $$props2.offset;
    if ("dispatch" in $$props2)
      dispatch = $$props2.dispatch;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [value, single, container, getStartListener, moveListener, div0_binding];
}
var Slider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { value: 0, single: 1 }, add_css3);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Slider",
      options,
      id: create_fragment3.name
    });
  }
  get value() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get single() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set single(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Slider_default = Slider;
export {
  Slider_default as default
};
//# sourceMappingURL=svelte-slider.js.map
